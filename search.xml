<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础</title>
      <link href="/2020/03/22/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/03/22/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>java入门篇—学习笔记(持续更新中…)</p><a id="more"></a><h1 id="第一章-JAVA语言概述"><a href="#第一章-JAVA语言概述" class="headerlink" title="第一章 JAVA语言概述"></a>第一章 JAVA语言概述</h1><h2 id="一、JAVA程序的种类"><a href="#一、JAVA程序的种类" class="headerlink" title="一、JAVA程序的种类"></a>一、JAVA程序的种类</h2><ol><li><p>Java小应用程序（<code>Java Applet</code>）</p><ul><li><p>在Web浏览器中运行（内嵌Java虚拟机）</p></li><li><p>特性标记</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;APPLET CODE="HelloWorld.class" WIDTH=150 HELGHT=25&gt;&lt;/APPLET&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Java应用程序（<code>Java APPlication</code>）</p></li></ol><h2 id="二、第一个Java程序"><a href="#二、第一个Java程序" class="headerlink" title="二、第一个Java程序"></a>二、第一个Java程序</h2><h3 id="2-1-代码编写"><a href="#2-1-代码编写" class="headerlink" title="2.1 代码编写"></a>2.1 代码编写</h3><ul><li><p>Java源程序名与程序内部的类名称必须一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所保存的文件名为：<code>MyClass.java</code></p><p><strong>注意：大小写敏感</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一行的第三个单词必须和所在的文件名完全一样，大小写也要一样。</span></span><br><span class="line"><span class="comment">// public class后面代表定义一个类的名称，类是Java当中所有源代码的基本组织单位。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helloworld</span></span>&#123;</span><br><span class="line">    <span class="comment">// 第二行的内容是万年不变的固定写法，代表main方法，是程序执行的起点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 打印输出语句Hello World！</span></span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2如何运行程序？"><a href="#2-2如何运行程序？" class="headerlink" title="2.2如何运行程序？"></a>2.2如何运行程序？</h3><ol><li>需要先使用<code>cmd</code>命令行，输入<code>javac Helloworld.java</code>进行编译；</li><li>编译完成后当前文件夹会创建<code>Helloworld.class</code>文件；</li><li>通过<code>java Helloworld</code>运行程序。</li></ol><h1 id="第二章-JAVA语法基础"><a href="#第二章-JAVA语法基础" class="headerlink" title="第二章 JAVA语法基础"></a>第二章 JAVA语法基础</h1><h2 id="一、语法规则"><a href="#一、语法规则" class="headerlink" title="一、语法规则"></a>一、语法规则</h2><h3 id="1-1程序设计语言中的5类符号"><a href="#1-1程序设计语言中的5类符号" class="headerlink" title="1.1程序设计语言中的5类符号"></a>1.1程序设计语言中的5类符号</h3><ul><li>关键字（保留字）</li><li>标识符</li><li>分隔符</li><li>常量数据</li><li>运算符</li></ul><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h3 id="2-1基本数据类型"><a href="#2-1基本数据类型" class="headerlink" title="2.1基本数据类型"></a>2.1基本数据类型</h3><ul><li>数字（<code>number</code>）<ul><li>整型（<code>integers</code>）<ol><li>字节整数（<code>byte</code>, <code>8 bits</code>）</li><li>短整数（<code>short</code>, <code>16 bits</code>）</li><li>整数（<code>int</code>, <code>32 bits</code>）</li><li>长整数（<code>long</code>, <code>64 bits</code>）</li></ol></li><li>实型（<code>real numbers</code>）：浮点数<ol><li>单精度（<code>float</code>, <code>32 bits</code>）</li><li>双精度（<code>double</code>, <code>64 bits</code>）</li></ol></li></ul></li><li>字符（<code>char</code>, <code>16 bits</code> <code>Unicode</code> 字符）</li><li>布尔（<code>boolean</code>）</li></ul><h3 id="2-2-复合数据类型"><a href="#2-2-复合数据类型" class="headerlink" title="2.2 复合数据类型"></a>2.2 复合数据类型</h3><ul><li>数组（<code>Array</code>），类（<code>class</code>），接口（<code>interface</code>）</li></ul><h3 id="2-3-常量数据表示"><a href="#2-3-常量数据表示" class="headerlink" title="2.3 常量数据表示"></a>2.3 常量数据表示</h3><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">178</span>;</span><br><span class="line"><span class="keyword">long</span> l = <span class="number">8864L</span>;(<span class="number">8864l</span>)</span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">37.266</span>;</span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">37.266</span>D;(<span class="number">37.266</span>d)</span><br><span class="line"><span class="keyword">double</span> d3 = <span class="number">26.77e3</span>;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">87.363F</span>;(<span class="number">87.363f</span>)</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'d'</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b2 = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="2-4-类型转换（casting）"><a href="#2-4-类型转换（casting）" class="headerlink" title="2.4 类型转换（casting）"></a>2.4 类型转换（<code>casting</code>）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">257</span>;</span><br><span class="line">        <span class="keyword">byte</span> b = (<span class="keyword">byte</span>)a;<span class="comment">//byte 类型转换</span></span><br><span class="line">        System.out.println(<span class="string">"a="</span> + a);</span><br><span class="line">       System.out.println(<span class="string">"b="</span> + b);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、常量和变量"><a href="#三、常量和变量" class="headerlink" title="三、常量和变量"></a>三、常量和变量</h2><h3 id="3-1常量"><a href="#3-1常量" class="headerlink" title="3.1常量"></a>3.1常量</h3><ul><li>程序执行过程中，值保持不变的量</li><li>整型常量<ul><li>常用十进制、八进制、十六进制表示</li><li>有正负号</li></ul></li><li>实型常量<ul><li>双精度实数（<code>double</code>，8个字节，数字后加字母D或d）</li><li>浮点实数（<code>float</code>，4个字节，数字后加字符F或f）</li><li>若无明确字母表示，则系统默认为双精度实数</li></ul></li><li>布尔型常量<ul><li>true</li><li>false</li></ul></li><li>字符型常量<ul><li>用单引号括起来的单个字符</li><li><code>JAVA</code>中的字符为<code>Unicode</code>字符</li></ul></li><li>字符串常量</li></ul><h3 id="3-2变量"><a href="#3-2变量" class="headerlink" title="3.2变量"></a>3.2变量</h3><ul><li><p>程序执行过程中，值可以改变的量</p></li><li><p>整型变量、实型变量、字符型变量、字符串变量、布尔变量等</p></li><li><p>变量定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="keyword">float</span> a,b;</span><br><span class="line"><span class="keyword">char</span> c1,c2;</span><br></pre></td></tr></table></figure></li><li><p>变量初始值/初始化</p></li><li><p>在变量声明时赋值</p></li><li><p>采用赋值语句</p></li><li><p>变量的作用域</p></li><li><p><code>final</code>变量</p><ul><li>带有关键字<code>final</code>的变量</li><li><code>final</code>变量初始化后不能再改变</li></ul></li></ul><h2 id="四、运算符和表达式"><a href="#四、运算符和表达式" class="headerlink" title="四、运算符和表达式"></a>四、运算符和表达式</h2><h3 id="4-1-运算符"><a href="#4-1-运算符" class="headerlink" title="4.1 运算符"></a>4.1 运算符</h3><ol><li>算术运算符</li><li>关系运算符<ul><li>比较运算，计算结果<code>true</code>或<code>flase</code></li></ul></li><li>逻辑运算符</li><li>位运算符</li><li>移位运算符</li><li>条件运算符</li></ol><h3 id="4-2-表达式"><a href="#4-2-表达式" class="headerlink" title="4.2 表达式"></a>4.2 表达式</h3><h2 id="五、语句"><a href="#五、语句" class="headerlink" title="五、语句"></a>五、语句</h2><h3 id="5-1-条件选择语句"><a href="#5-1-条件选择语句" class="headerlink" title="5.1 条件选择语句"></a>5.1 条件选择语句</h3><ul><li>if语句<ul><li>if语句是一个条件表达式，若条件表达式为真，则执行下面的代码块，否则跳过该代码块。</li></ul></li><li>条件运算符<ul><li>三元运算符</li></ul></li><li>switch开关语句<ul><li>根据表达式的结果执行多个操作中的一个</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题</title>
      <link href="/2019/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/10/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>本文整理了一些基础的知识点以及面试经常问到的问题。（持续更新）</p><a id="more"></a><h2 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h2><h3 id="1-HTML5增加了哪些新特征？"><a href="#1-HTML5增加了哪些新特征？" class="headerlink" title="1. HTML5增加了哪些新特征？"></a>1. <code>HTML5</code>增加了哪些新特征？</h3><ul><li>新的结构元素（头部<code>header</code>、导航<code>nav</code>、主要内容<code>main</code>、底部<code>footer</code>、页面中一个内容区域<code>section</code>、与主区域内容没有关联的内容<code>aside</code>、独立的流内容<code>figure</code>）</li><li>新的功能元素（视频<code>video</code>、音频<code>audio</code>、资源<code>source</code>、画布<code>canvas</code>、任务进度<code>progress</code>）</li><li><code>input</code>新增的<code>type</code>类型（输入电话<code>tel</code>、滑动条<code>range</code>、包含数值的输入域<code>number</code>、邮箱<code>email</code>、选择日期<code>date</code>、选择月份<code>month</code>、选择周和年<code>week</code>、选择时间<code>time</code>、选取颜色<code>color</code>）</li><li>拖放（<code>Drag</code>和<code>Drop</code>）</li><li>文件操作</li><li>本地离线存储<code>localStorage</code>长期存储数据，浏览器关闭后数据不丢失</li><li><code>sessionStorage</code>的数据在浏览器关闭后自动删除</li><li>新的技术（多线程处理<code>webWorker</code>、双向通信<code>websocket</code>、地理定位<code>Geolocation</code>）</li></ul><h3 id="2-lt-img-gt-的title和alt有什么区别？"><a href="#2-lt-img-gt-的title和alt有什么区别？" class="headerlink" title="2. &lt;img&gt;的title和alt有什么区别？"></a>2. <code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别？</h3><p><code>title</code>通常当鼠标滑动到元素上的时候显示。</p><p><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</p><h3 id="3-iframe有哪些缺点？"><a href="#3-iframe有哪些缺点？" class="headerlink" title="3. iframe有哪些缺点？"></a>3. iframe有哪些缺点？</h3><p><code>iframe</code>会阻塞主页面的<code>onload</code>事件，搜索引擎的检索程序无法读取这种页面，不利于<code>SEO</code>。</p><p><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p><p>建议：通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值。</p><h3 id="4-HTML全局属性（global-attribute）有哪些？"><a href="#4-HTML全局属性（global-attribute）有哪些？" class="headerlink" title="4. HTML全局属性（global attribute）有哪些？"></a>4. HTML全局属性（global attribute）有哪些？</h3><ul><li><code>id</code>：元素<code>id</code>，文档内唯一。</li><li><code>class</code>：为元素设置类标识。</li><li><code>data-*</code>：为元素增加自定义属性。</li><li><code>draggable</code>：设置元素是否可拖拽。</li><li><code>lang</code>：元素内容的语言。</li><li><code>style</code>：行内<code>css</code>样式。</li><li><code>title</code>：元素相关的建议信息（鼠标悬停显示）。</li></ul><h2 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h2><h3 id="1-CSS3增加了哪些新特征？"><a href="#1-CSS3增加了哪些新特征？" class="headerlink" title="1. CSS3增加了哪些新特征？"></a>1. <code>CSS3</code>增加了哪些新特征？</h3><ul><li>新增各种<code>css</code>选择器</li><li>圆角<code>border-radius</code></li><li>阴影<code>box-shadow</code></li><li>文本效果（<code>text-shadow</code>、<code>text-overflow</code>、<code>word-wrap</code>、<code>word-break</code>）</li><li>字体（<code>@font-face</code>）</li><li>框大小（<code>box-sizing</code>）</li><li><code>rgba</code></li><li>线性渐变<code>linear-gradient</code>、径向渐变<code>radial-gradient</code></li><li>新增了四种背景属性（<code>background-image</code>、<code>background-size</code>、<code>background-origin</code>、<code>background-clip</code>）</li><li>多列布局（<code>columns</code>）</li><li>弹性盒子（<code>Flex</code>）</li><li>媒体查询（<code>@media</code>）</li><li>2D、3D（形状变化<code>transform</code>、过渡<code>transition</code>）</li></ul><h3 id="2-让一个元素水平和垂直居中有哪些方法？"><a href="#2-让一个元素水平和垂直居中有哪些方法？" class="headerlink" title="2. 让一个元素水平和垂直居中有哪些方法？"></a>2. 让一个元素水平和垂直居中有哪些方法？</h3><p>   <strong>水平居中</strong></p><ul><li><p>元素为行内元素，设置父元素<code>text-align:center</code></p></li><li><p>如果元素宽度固定，可以设置左右<code>margin</code>为<code>auto</code></p></li><li><p>如果元素为绝对定位，设置父元素<code>position</code>为<code>relative</code>，元素设置<code>left:0;right:0;margin:auto;</code></p></li><li><p>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为<code>center</code></p></li><li><p><code>display</code>设置为<code>tabel-ceil</code></p></li><li><p><em>垂直居中*</em></p></li><li><p>将显示方式设置为表格，<code>display:table-cell</code>，同时设置<code>vertial-align:middle</code></p></li><li><p>使用<code>flex</code>布局，设置<code>align-item:center</code></p></li><li><p>绝对定位中设置<code>bottom:0;top:0;</code>并设置<code>margin:auto;</code></p></li><li><p>绝对定位中固定高度时设置<code>top:50%;margin-top</code>值为高度一半的负值</p></li><li><p>文本垂直居中设置<code>line-height</code>为<code>height</code>值</p></li></ul><h3 id="3-position有哪些属性？"><a href="#3-position有哪些属性？" class="headerlink" title="3. position有哪些属性？"></a>3. <code>position</code>有哪些属性？</h3><ul><li><code>absolute</code>：生成绝对定位的元素，相对于<code>static</code>定位以外的第一个父元素进行定位</li><li><code>fixed</code>：生成绝对定位的元素，相对于浏览器窗口进行定位</li><li><code>relative</code>：生成相对定位的元素，相对于其正常位置进行定位</li><li><code>static</code>：默认值。没有定位，元素出现在正常的流中</li><li><code>inherit</code>：规定从父元素继承<code>position</code>属性的值</li></ul><h3 id="4-盒模型有哪些，区别是什么？如何设置？"><a href="#4-盒模型有哪些，区别是什么？如何设置？" class="headerlink" title="4. 盒模型有哪些，区别是什么？如何设置？"></a>4. 盒模型有哪些，区别是什么？如何设置？</h3><p>   有两种：<code>IE</code>盒模型、标准盒模型</p><p>   区别：<code>IE</code>盒子的宽度由<code>width</code>决定，而标准盒模型的宽度 = <code>width</code> + <code>padding</code> + <code>border</code></p><p>可以通过：</p><ul><li><p><code>box-sizing：content-box</code>设置标准盒模型（默认）</p></li><li><p><code>box-sizing:border-box</code>设置<code>IE</code>盒模型</p></li></ul><h3 id="5-清除浮动的方法"><a href="#5-清除浮动的方法" class="headerlink" title="5. 清除浮动的方法"></a>5. 清除浮动的方法</h3><ul><li>父级<code>div</code>定义<code>height</code></li><li>结尾处加空<code>div</code>标签<code>clear:both</code></li><li>父级<code>div</code>定义伪类<code>:after</code>和<code>zoom</code></li><li>父级<code>div</code>定义<code>overflow:hidden</code></li><li>父级<code>div</code>也浮动，需要定义宽度</li><li>结尾处加<code>br</code>标签<code>clear:both</code></li></ul><h3 id="6-CSS有哪几种引入方式？"><a href="#6-CSS有哪几种引入方式？" class="headerlink" title="6. CSS有哪几种引入方式？"></a>6. CSS有哪几种引入方式？</h3><ul><li><p>内部样式表（写在<code>style</code>标签里）</p></li><li><p>外部样式表（通过<code>link</code>标签引入）</p></li><li><p>行间样式表</p><p>注意：行间样式权重最高。<code>link</code>引入的文件是异步加载的。</p><p>权重：<code>！import</code>（无限大） &gt; 行间样式（1000） &gt; id选择器（100） &gt; class选择器 || 属性选择器 || 伪类选择器（10） &gt; 标签选择器（1） &gt; 通配符选择器（0）</p></li></ul><h3 id="7-Canvas和SVG有什么区别？"><a href="#7-Canvas和SVG有什么区别？" class="headerlink" title="7. Canvas和SVG有什么区别？"></a>7. Canvas和SVG有什么区别？</h3><p><code>svg</code>绘制出来的每一个图形的元素都是独立的<code>DOM</code>节点，能够方便的绑定事件或用来修改。<code>canvas</code>输出的是一整幅画布。</p><p><code>svg</code>输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而<code>canvas</code>输出标量画布，就像一张图片一样，放大会失真或者锯齿。</p><h3 id="8-display-none-与visibility-hidden-的区别"><a href="#8-display-none-与visibility-hidden-的区别" class="headerlink" title="8. display: none;与visibility: hidden;的区别"></a>8. <code>display: none;</code>与<code>visibility: hidden;</code>的区别</h3><p>联系：他们都能让元素不可见。</p><p>区别：</p><ul><li><code>display: none;</code>会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden;</code>不会让元素从渲染树消失，渲染的元素继续占据空间，只是内容不可见。</li><li><code>display: none;</code>是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility: hidden;</code>是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible;</code>可以让子孙节点显示。</li><li>修改常规流中元素中的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘。</li><li>读屏器不会读取<code>display: none;</code>元素内容，会读取<code>visibility: hidden;</code>元素内容。</li></ul><h3 id="9-JS如何设置获取盒模型对应的宽和高？"><a href="#9-JS如何设置获取盒模型对应的宽和高？" class="headerlink" title="9. JS如何设置获取盒模型对应的宽和高？"></a>9. JS如何设置获取盒模型对应的宽和高？</h3><ul><li><code>dom.style.width/height</code>：只能获取使用内联样式元素的宽和高。</li><li><code>dom.currentStyle.width/height</code>：获取的是浏览器渲染以后元素的宽和高，无论是用何种方式引入的css样式都可以，但只有IE浏览器支持这种写法。</li><li><code>window.getComputedStyle(dom).width/height</code>：这种方法获取的也是浏览器渲染以后的元素的宽和高，但这种写法兼容性更好一些。</li><li><code>dom.getBoundingClientRect().width/height</code>：这种方法经常使用的场所是，计算一个元素的绝对位置（相对于视窗左上角），它能拿到元素的<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code>4个属性。</li></ul><h3 id="10-如何创建块级格式化上下文（block-formatting-context），BFC有什么用？"><a href="#10-如何创建块级格式化上下文（block-formatting-context），BFC有什么用？" class="headerlink" title="10. 如何创建块级格式化上下文（block formatting context），BFC有什么用？"></a>10. 如何创建块级格式化上下文（<code>block formatting context</code>），BFC有什么用？</h3><p><strong>创建规则</strong>：</p><ul><li>根元素</li><li>浮动元素（<code>float</code>不取值为<code>none</code>）</li><li>绝对定位元素（<code>position</code>取值为<code>absolute</code>或<code>fixed</code>）</li><li><code>display</code>取值为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、’inline-flex’之一的元素</li><li><code>overflow</code>不取值为<code>visible</code>的元素</li></ul><p><strong>作用：</strong></p><ul><li>可以包含浮动元素</li><li>不被浮动元素覆盖</li><li>阻止父子元素的<code>margin</code>折叠</li></ul><h3 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h3><h2 id="三、JavaScript"><a href="#三、JavaScript" class="headerlink" title="三、JavaScript"></a>三、JavaScript</h2><h3 id="1-JavaScript有哪几种方式查找Dom节点？"><a href="#1-JavaScript有哪几种方式查找Dom节点？" class="headerlink" title="1. JavaScript有哪几种方式查找Dom节点？"></a>1. <code>JavaScript</code>有哪几种方式查找<code>Dom</code>节点？</h3><ol><li>通过ID获取（<code>document.getElementById(&#39;id&#39;)</code>）</li><li>通过name属性（<code>document.getElementByName(&#39;name&#39;)</code>）</li><li>通过标签名（<code>document.getElementByTagName(&#39;div&#39;)</code>）</li><li>通过类名（<code>document.getElementByClassName(&#39;name&#39;)</code>）</li><li>通过选择器获取一个元素（<code>document.querySelector(&#39;.example&#39;)</code>）</li><li>通过选择器获取一组元素（<code>document.querySelectorAll(&#39;.example&#39;)</code>）</li></ol><h3 id="2-ES6新增了哪些语法？"><a href="#2-ES6新增了哪些语法？" class="headerlink" title="2. ES6新增了哪些语法？"></a>2. <code>ES6</code>新增了哪些语法？</h3><ul><li>新增了模板字符串</li><li>箭头函数</li><li><code>for-of</code>（用来遍历数据）</li><li><code>arguments</code></li><li><code>promise</code></li><li>增加了<code>let</code>、<code>const</code>命令</li><li>引入了<code>module</code>模块的概念</li></ul><h3 id="3-AJAX的原理"><a href="#3-AJAX的原理" class="headerlink" title="3. AJAX的原理"></a>3. <code>AJAX</code>的原理</h3><p>   <code>Ajax</code>的原理简单来说是在用户和服务器之间加了中间层（<code>ajax</code>引擎），通过<code>XMLHTTPRequest</code>对象来向服务器发送异步请求，从服务器获得数据，然后用<code>javascript</code>来操纵<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建连接</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 2. 连接服务器 </span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, url, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 3. 发送请求 </span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 4. 接受请求 </span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">success(xhr.responseText);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="comment">// false </span></span><br><span class="line">fail &amp;&amp; fail(xhr.status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <strong><code>ajax</code>有哪些优缺点？</strong></p><ul><li><p>优点：</p><ul><li>通过异步模式，提升了用户体验</li><li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用</li><li><code>Ajax</code>在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载</li><li><code>Ajax</code>可以实现动态不刷新（局部刷新）</li></ul></li><li><p>缺点：</p><ul><li>安全问题<code>AJAX</code>暴露了与服务器交互的细节.</li><li>对搜索引擎的支持比较弱。</li><li>不容易调试。</li></ul></li></ul><h3 id="4-ajax与axios的区别"><a href="#4-ajax与axios的区别" class="headerlink" title="4. ajax与axios的区别"></a>4. <code>ajax</code>与<code>axios</code>的区别</h3><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</p><ul><li>从浏览器中创建<code>XMLHTTPRequest</code></li><li>从<code>node.js</code>创建<code>http</code>请求</li><li>支持<code>Promise API</code></li><li>客户端支持防止<code>CSRF</code></li><li>提供了一些并发请求的接口（方便了很多操作）</li></ul><h3 id="5-var、let、const的区别"><a href="#5-var、let、const的区别" class="headerlink" title="5. var、let、const的区别"></a>5. <code>var</code>、<code>let</code>、<code>const</code>的区别</h3><ul><li><p><code>var</code></p><p>声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的<br>由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明</p></li><li><p><code>let</code></p><p>允许你声明一个作用域被限制在块级中的变量、语句或者表达式<br>let绑定不受变量提升的约束，这意味着<code>let</code>声明不会被提升到当前<br>该变量处于从块开始到初始化处理的“暂存死区”</p></li><li><p><code>const</code></p><p>声明创建一个值的只读引用 (即指针)<br>基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 const申明基本数据类型时<br>再将其值改变时，将会造成报错， 例如 <code>const a = 3 ; a = 5</code>时 将会报错<br>但是如果是复合类型时，如果只改变复合类型的其中某个<code>Value</code>项时， 将还是正常使用</p></li></ul><h3 id="6-什么是深拷贝、浅拷贝，他们的区别是什么？"><a href="#6-什么是深拷贝、浅拷贝，他们的区别是什么？" class="headerlink" title="6. 什么是深拷贝、浅拷贝，他们的区别是什么？"></a>6. 什么是深拷贝、浅拷贝，他们的区别是什么？</h3><h3 id="7-简单的说下原型链"><a href="#7-简单的说下原型链" class="headerlink" title="7. 简单的说下原型链"></a>7. 简单的说下原型链</h3><p>   每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。<br>   每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了<code>[[prototype]]</code>，但是 <code>[[prototype]]</code>是内部属性，我们并不能访问到，所以使用 <code>__proto__</code>来访问。<br>   对象可以通过<code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code>将对象连接起来组成了原型链。</p><h3 id="8-JavaScript原型，原型链-有什么特点？"><a href="#8-JavaScript原型，原型链-有什么特点？" class="headerlink" title="8.  JavaScript原型，原型链 ? 有什么特点？"></a>8.  JavaScript原型，原型链 ? 有什么特点？</h3><p>   每个对象都会在其内部初始化一个属性，就是<code>prototype</code>（原型），当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去<code>prototype</code>里找这个属性，这个<code>prototype</code>又会有自己的<code>prototype</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念</p><p>   <strong>关系</strong>：<br>   <code>instance.constructor.prototype = instance.__proto__</code></p><p>   <strong>特点</strong>：<br>   <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。<br>   当我们需要一个属性时，<code>JavaScript</code>引擎会先看当前对象中是否有这个属性，如果没写的就会查找他的<code>Prototype</code>对象是否有这个属性，如此递推下去，一直检索到<code>Object</code>内建对象。</p><h3 id="9-JS加载时间线"><a href="#9-JS加载时间线" class="headerlink" title="9. JS加载时间线"></a>9. JS加载时间线</h3><ol><li>创建<code>Document</code>对象，开始解析<code>web</code>页面，解析<code>HTML</code>元素和他们的文本内容后添加<code>Element</code>对象和<code>Text</code>节点到文档中。这个阶段<code>Document.readyState = &#39;loading&#39;</code>。</li><li>遇到<code>link</code>外部<code>CSS</code>，创建线程加载，并继续解析文档。</li><li>遇到<code>script</code>外部<code>js</code>，并且没有设置<code>async</code>、<code>defer</code>，浏览器加载并阻塞，等待<code>js</code>加载完成并执行该脚本，然后继续解析文档。</li><li>遇到<code>script</code>外部<code>js</code>，并且设置<code>async</code>、<code>defer</code>，浏览器创建线程加载，并继续解析文档。对于<code>async</code>属性的脚本，脚本加载完成后立即执行。</li><li>遇到<code>img</code>标签等，先正常解析<code>DOM</code>结构，然后浏览器异步加载<code>src</code>，并继续解析文档。</li><li>当文档解析完成，<code>document.readyState = &#39;interactive&#39;</code>。</li><li>文档解析完成后，所有设置有<code>defer</code>的脚本会按照顺序执行。</li><li>当文档解析完成后，<code>document</code>对象触发<code>DOMContentLoaded</code>事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</li><li>当所有<code>async</code>的脚本加载完成并执行后，<code>img</code>等加载完成后，<code>document.readyState = &#39;complete&#39;</code>，<code>window</code>对象触发<code>load</code>事件。</li><li>从此，页面以异步响应方式处理用户输入，网络事件等。</li></ol><h3 id="10-创建对象有哪几种方法？"><a href="#10-创建对象有哪几种方法？" class="headerlink" title="10. 创建对象有哪几种方法？"></a>10. 创建对象有哪几种方法？</h3><ol><li>对象字面量的方式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>: <span class="string">"o1"</span>&#125;；</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>: <span class="string">"o2"</span>&#125;)；</span><br></pre></td></tr></table></figure><ol start="2"><li>使用构造函数创建对象</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name = name&#125;；</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">'o3'</span>)；</span><br></pre></td></tr></table></figure><ol start="3"><li><code>Object.create</code></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">'p'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(p)</span><br></pre></td></tr></table></figure><h3 id="11-1"><a href="#11-1" class="headerlink" title="11."></a>11.</h3><h2 id="四、jQuery"><a href="#四、jQuery" class="headerlink" title="四、jQuery"></a>四、jQuery</h2><h3 id="1-jquery如何更改css样式？"><a href="#1-jquery如何更改css样式？" class="headerlink" title="1. jquery如何更改css样式？"></a>1. <code>jquery</code>如何更改<code>css</code>样式？</h3><h2 id="五、VUE"><a href="#五、VUE" class="headerlink" title="五、VUE"></a>五、VUE</h2><h3 id="1-请详细说下你对vue生命周期的理解"><a href="#1-请详细说下你对vue生命周期的理解" class="headerlink" title="1. 请详细说下你对vue生命周期的理解"></a>1. 请详细说下你对<code>vue</code>生命周期的理解</h3><p>   答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p><p>   <strong>创建前/后</strong>：在<code>beforeCreate</code>阶段，<code>vue</code>实例在挂载元素<code>el</code>和数据对象<code>data</code>都为<code>undefined</code>，还未初始化。在<code>created</code>阶段，<code>vue</code>实例的数据对象<code>data</code>有了，<code>el</code>还没有</p><p>   <strong>载入前/后</strong>：在<code>beforeMount</code>阶段，<code>vue</code>实例的<code>el</code>和<code>data</code>都初始化了，但是还是挂载之前为虚拟的<code>dom</code>节点，<code>data.message</code>还未替换。在<code>mouted</code>阶段，<code>vue</code>实例挂载完成，<code>data.message</code>成功渲染。</p><p>   <strong>更新前/后</strong>：当<code>data</code>变化时，会触发<code>beforeUpdate</code>和<code>updated</code>方法。</p><p>   <strong>销毁前/后</strong>：在执行<code>destroy</code>方法后，对<code>data</code>的改变不会触发周期函数，说明此事<code>vue</code>实例已经解除了事件监听以及和<code>dom</code>的绑定，但是<code>dom</code>结构依然存在。</p><h3 id="2-什么是vue声明周期？"><a href="#2-什么是vue声明周期？" class="headerlink" title="2. 什么是vue声明周期？"></a>2. 什么是<code>vue</code>声明周期？</h3><p>   答：<code>vue</code>实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 <code>Vue</code>的生命周期。</p><h3 id="3-vue生命周期的作用是什么？"><a href="#3-vue生命周期的作用是什么？" class="headerlink" title="3. vue生命周期的作用是什么？"></a>3. <code>vue</code>生命周期的作用是什么？</h3><p>   生命周期中有多个事件钩子函数，让我们在控制整个<code>vue</code>实例的过程中更容易形成好的逻辑。</p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><h2 id="六、网络"><a href="#六、网络" class="headerlink" title="六、网络"></a>六、网络</h2><h3 id="1-从地址栏输入网址到页面展示经过了哪些步骤？"><a href="#1-从地址栏输入网址到页面展示经过了哪些步骤？" class="headerlink" title="1. 从地址栏输入网址到页面展示经过了哪些步骤？"></a>1. 从地址栏输入网址到页面展示经过了哪些步骤？</h3><ol><li>在地址栏输入<code>url</code>。</li><li>浏览器会向<code>DNS</code>服务器发送请求，解析返回<code>IP</code>地址（地址会存储在本地文件里<code>hosts</code>）。</li><li>拿到<code>IP</code>地址，会进行<code>TCP/IP</code>连接，三次握手。</li><li>浏览器向<code>web</code>服务器发送（<code>ajax</code>）请求。</li><li><code>web</code>服务器接收处理请求。</li><li>浏览器接收文件（<code>HTML</code>、<code>JS</code>、<code>CSS</code>、图象等）。</li><li><code>TCP/IP</code>关闭，四次挥手。</li><li>载入解析到的资源文件，渲染页面。  </li></ol><h3 id="2-HTTP和HTTPS的区别"><a href="#2-HTTP和HTTPS的区别" class="headerlink" title="2. HTTP和HTTPS的区别"></a>2. <code>HTTP</code>和<code>HTTPS</code>的区别</h3><ol><li><code>https</code>协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li><li><code>http</code>是超文本传输协议，信息是明文传输，<code>https</code>则是具有安全性的<code>ssl</code>加密传输协议。</li><li><code>http</code>和<code>https</code>使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li><code>http</code>的连接很简单，是无状态的。<code>Https</code>协议是由<code>SSL</code>+<code>Http</code>协议构建的可进行加密传输、身份认证的网络协议，比<code>http</code>协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</li></ol><h3 id="3-什么是同源？"><a href="#3-什么是同源？" class="headerlink" title="3. 什么是同源？"></a>3. 什么是同源？</h3><p>同源策略是浏览器的一种安全策略。只有协议、域名、端口均相同的源才属于同源。</p><h3 id="4-什么是跨域？有哪几种解决方案？"><a href="#4-什么是跨域？有哪几种解决方案？" class="headerlink" title="4. 什么是跨域？有哪几种解决方案？"></a>4. 什么是跨域？有哪几种解决方案？</h3><p>因为浏览器处于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，<code>Ajax</code>请求会失败。</p><p>解决方案：</p><ol><li><code>JSONP</code></li><li><code>CORS</code></li><li><code>document.domain</code></li><li><code>postMessage</code></li></ol><h3 id="5-JSOP的请求方式和优缺点"><a href="#5-JSOP的请求方式和优缺点" class="headerlink" title="5. JSOP的请求方式和优缺点"></a>5. JSOP的请求方式和优缺点</h3><p>由于<code>script</code>的<code>src</code>不受同源策略的限制，所以可以用<code>src</code>进行跨域请求数据。</p><p><strong>请求方式：</strong></p><p>在发送请求的时候，要把回调函数的名称拼接到<code>url</code>的后面给服务器发送过去。这样后端在处理的时候，会提取出来回调函数的名称，拼接成函数执行的方式返回回来，一旦响应请求回来，回调函数就会执行。</p><p><strong>优点：</strong></p><p>兼容性好，简单易用，支持浏览器与服务器双向通信。</p><p><strong>缺点：</strong></p><p>只能支持<code>GET</code>请求</p><h3 id="6-cookie原理"><a href="#6-cookie原理" class="headerlink" title="6. cookie原理"></a>6. cookie原理</h3><p><code>HTTP</code>是无状态的请求/响应连接，当连接断开后，再次连接服务器无法识别用户。我们希望用户再次访问的时候，能够识别它，给他个性化的服务。<code>cookie</code>可以帮助我们弥补这个缺陷实现标记跟踪用户。</p><p><strong>原理：</strong></p><ol><li>当首次访问<code>web</code>站点的时候，服务器会返回响应的时候会带有响应首部<code>set-cookie</code>字段。</li><li>浏览器会自动的把响应的<code>cookie</code>存储在浏览器的数据库中。</li><li>当用户再次访问同一站点时，浏览器会把存储的<code>cookie</code>一起带上发送出去，这样服务器拿到请求的同时也拿到了这个<code>cookie</code>字段。</li></ol><h3 id="7-CORS跨域"><a href="#7-CORS跨域" class="headerlink" title="7.CORS跨域"></a>7.CORS跨域</h3><p><code>cross-origin resource sharing</code> (<code>CORS</code>) 跨域资源共享，是一种使用额外HTTP首部实现跨域获取资源权限的机制。</p><p>除了正常发起请求外，若想实现cors跨域，还需要服务器配置正确的响应首部。否则无法获取<br><code>access-contral-allow-origin: *(localhost)</code> 访问控制允许源。</p><p>主要由后端配置。</p><h3 id="8-HTTP的有哪些请求方式？"><a href="#8-HTTP的有哪些请求方式？" class="headerlink" title="8. HTTP的有哪些请求方式？"></a>8. HTTP的有哪些请求方式？</h3><ol><li><p><code>GET</code>请求</p><ul><li>发送一个请求来取得浏览器上的某一资源</li></ul></li><li><p><code>POST</code>方法</p><ul><li>向<code>URL</code>指定的资源提交数据或附加新的数据</li></ul></li><li><p><code>PUT</code>方法</p><ul><li>跟<code>post</code>方法很像也是向服务器提交数据。但是，他们之间有不同，<code>PUT</code>制定了资源在服务器上的位置，而<code>POST</code>没有</li></ul></li><li><p><code>HEAD</code>方法</p><ul><li>只请求页面的首部</li></ul></li><li><p><code>DELETE</code>方法</p><ul><li>删除服务器上的某资源</li></ul></li><li><p><code>OPITINS</code>方法</p><ul><li>它用于获取当前<code>URL</code>所支持的方法。如果请求成功，会有一个<code>Allow</code>的头包含类似<code>GET</code>、<code>POST</code>这样的信息。</li></ul></li><li><p><code>TEACE</code>方法</p><ul><li><code>teace</code>方法被用于激发一个远程的，应用层的请求消息回路</li></ul></li><li><p><code>CONNECT</code>方法</p><ul><li>把请求连接转换成透明的<code>TCP/IP</code>通道</li></ul></li></ol><h3 id="9-HTTP状态码及含义"><a href="#9-HTTP状态码及含义" class="headerlink" title="9.  HTTP状态码及含义"></a>9.  HTTP状态码及含义</h3><p><strong>1XX：信息状态码</strong></p><ul><li><code>100 Continue</code> 继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li></ul><p><strong>2XX：成功状态码</strong></p><ul><li><code>200 OK</code> 正常返回信息</li><li><code>201 Created</code> 请求成功并且服务器创建了新的资源</li><li><code>202 Accepted</code> 服务器已接受请求，但尚未处理</li></ul><p><strong>3XX：重定向</strong></p><ul><li><code>301 Moved Permanently</code> 请求的网页已永久移动到新位置。</li><li><code>302 Found</code> 临时性重定向。</li><li><code>303 See Other</code> 临时性重定向，且总是使用 <code>GET</code> 请求新的 <code>URI</code>。</li><li><code>304 Not Modified</code> 自从上次请求后，请求的网页未修改过。</li></ul><p><strong>4XX：客户端错误</strong></p><ul><li><code>400 Bad Request</code> 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li><li><code>401 Unauthorized</code> 请求未授权。</li><li><code>403 Forbidden</code> 对被请求页面的访问被禁止。</li><li><code>404 Not Found</code> 找不到如何与 <code>URI</code> 相匹配的资源。</li></ul><p><strong>5XX：服务器错误</strong></p><ul><li><code>500 Internal Server Error</code> 最常见的服务器端错误。</li><li><code>503 Service Unavailable</code> 服务器端暂时无法处理请求（可能是过载或维护）</li></ul><h3 id="10-HTTP协议的主要特点"><a href="#10-HTTP协议的主要特点" class="headerlink" title="10. HTTP协议的主要特点"></a>10. HTTP协议的主要特点</h3><ul><li>简单快速</li><li>灵活</li><li>无连接</li><li>无状态</li></ul><h3 id="11-POST和GET的区别"><a href="#11-POST和GET的区别" class="headerlink" title="11. POST和GET的区别"></a>11. POST和GET的区别</h3><ul><li><code>GET</code>在浏览器回退时是无害的，而<code>POST</code>会再次提交请求</li><li><code>GET</code>产生的<code>URL</code>地址可以被收藏，而<code>POST</code>不可以</li><li><code>GET</code>请求会被浏览器主动缓存，而<code>POST</code>不会，除非手动设置</li><li><code>GET</code>请求只能进行<code>url</code>编码，而<code>POST</code>支持多种编程方式</li><li><code>GET</code>请求参数会被完整保留在浏览器历史记录里，而<code>POST</code>中的参数不会被保留</li><li><code>GET</code>请求在<code>URL</code>中传送的参数是有长度限制的，而<code>POST</code>没有限制</li><li>对参数的数据类型，<code>GET</code>只接受<code>ASCII</code>字符，而<code>POST</code>没有限制</li><li><code>GET</code>比<code>POST</code>更不安全，因为参数直接暴露在<code>URL</code>上，多以不能用来传递敏感信息</li><li><code>GET</code>参数通过<code>URL</code>传递，<code>POST</code>放在<code>Request body</code>中</li></ul><h3 id="12-什么是持久连接？"><a href="#12-什么是持久连接？" class="headerlink" title="12. 什么是持久连接？"></a>12. 什么是持久连接？</h3><p><code>HTTP</code>协议采用“请求-应答”模式，当使用普通模式，即非<code>Keep-Alive</code>模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）</p><p>当使用<code>Keep-Alive</code>模式（又称持久链接，连接重用）时，<code>Keep-Alive</code>功能使客户端到服务器端的链接持续有效，当出现对服务器的后继请求时，<code>Kepp-Alive</code>功能避免了建立或者重新建立连接。</p><h3 id="13-cookie和session的区别"><a href="#13-cookie和session的区别" class="headerlink" title="13. cookie和session的区别"></a>13. cookie和session的区别</h3><ol><li><code>cookie</code>数据存放在客户端的浏览器上，而<code>session</code>数据放在服务器上。</li><li><code>cookie</code>不是很安全，别人可以分析存放在本地的<code>cookie</code>并进行<code>cookie</code>欺骗。（考虑到安全应当使用<code>cookie</code>）。</li><li><code>session</code>会在一定时间内保存在服务器上。当访问量增对，会比较占用你的服务器性能。（考虑到减轻服务器性能方面，应当使用<code>cookie</code>）。</li><li>单个<code>cookie</code>的数据不能超过4K，很多浏览器都限制一个站点最多保存20个<code>cookie</code>。</li><li>所以建议：<ul><li>将登录信息等重要信息存放在<code>session</code>中</li><li>其他信息如果需要保留可以放在<code>cookie</code>中</li></ul></li></ol><h3 id="14-描述cookie、sessionStorage和localStorage的区别"><a href="#14-描述cookie、sessionStorage和localStorage的区别" class="headerlink" title="14. 描述cookie、sessionStorage和localStorage的区别"></a>14. 描述cookie、sessionStorage和localStorage的区别</h3><ol><li>与服务器交互：<ul><li><code>cookie</code>是网站为了标识用户身份而存储在本地终端上的数据（通常经过加密）。</li><li><code>cookie</code>始终会在同源<code>http</code>请求头中携带（即使不需要），在浏览器和服务器间来回传递。</li><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存。</li></ul></li><li>存储大小<ul><li><code>cookie</code>数据根据不同浏览器限制，大小一般不超过4K。</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有大小限制，但比<code>cookie</code>大的多，可以达到5M或更大。</li></ul></li><li>有效时间</li></ol><ul><li><code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据。</li><li><code>seesionStorage</code>数据在当前浏览器窗口关闭后自动删除。</li><li><code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，与浏览器是否关闭无关。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/2019/09/20/Flex%E5%B8%83%E5%B1%80/"/>
      <url>/2019/09/20/Flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex是Flexible Box的缩写，意为“弹性布局”，用来为盒装模型体重最大的灵活性。<br>任何一个容器都可以指定为Flex布局。</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用 Flex 布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：设为Flex布局以后，子元素的<code>float</code>、<code>clear</code>、<code>vertical-align</code>属性将失效。</p><p>容器默认存在两根轴：水平的主轴（<code>main axis</code>）和垂直的交叉轴（<code>cross axis</code>）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="二、容器的属性"><a href="#二、容器的属性" class="headerlink" title="二、容器的属性"></a>二、容器的属性</h2><table><thead><tr><th align="center">属性</th><th align="center">用法</th></tr></thead><tbody><tr><td align="center"><code>flex-direction</code></td><td align="center">主轴的方向</td></tr><tr><td align="center"><code>flex-wrap</code></td><td align="center">如何换行</td></tr><tr><td align="center"><code>flex-flow</code></td><td align="center"><code>flex-direction</code>和<code>flex-wrap</code>的简写形式</td></tr><tr><td align="center"><code>justify-content</code></td><td align="center">主轴上的对齐方式</td></tr><tr><td align="center"><code>align-items</code></td><td align="center">交叉轴上如何对齐</td></tr><tr><td align="center"><code>align-content</code></td><td align="center">多根轴线的对齐方式</td></tr></tbody></table><h3 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line"><span class="comment">/*row（默认值）：主轴为水平方向，起点在左端。</span></span><br><span class="line"><span class="comment">    row-reverse：主轴为水平方向，起点在右端。</span></span><br><span class="line"><span class="comment">    column：主轴为垂直方向，起点在上沿。</span></span><br><span class="line"><span class="comment">    column-reverse：主轴为垂直方向，起点在下沿。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">nowrap（默认）：不换行。</span></span><br><span class="line"><span class="comment">wrap：换行，第一行在上方。</span></span><br><span class="line"><span class="comment">wrap-reverse：换行，第一行在下方。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    flex-start（默认值）：左对齐</span></span><br><span class="line"><span class="comment">    flex-end：右对齐</span></span><br><span class="line"><span class="comment">    center： 居中</span></span><br><span class="line"><span class="comment">    space-between：两端对齐，项目之间的间隔都相等。</span></span><br><span class="line"><span class="comment">    space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    flex-start：交叉轴的起点对齐。</span></span><br><span class="line"><span class="comment">    flex-end：交叉轴的终点对齐。</span></span><br><span class="line"><span class="comment">    center：交叉轴的中点对齐。</span></span><br><span class="line"><span class="comment">    baseline: 项目的第一行文字的基线对齐。</span></span><br><span class="line"><span class="comment">    stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    flex-start：与交叉轴的起点对齐。</span></span><br><span class="line"><span class="comment">    flex-end：与交叉轴的终点对齐。</span></span><br><span class="line"><span class="comment">    center：与交叉轴的中点对齐。</span></span><br><span class="line"><span class="comment">    space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span></span><br><span class="line"><span class="comment">    space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span></span><br><span class="line"><span class="comment">    stretch（默认值）：轴线占满整个交叉轴</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、项目的属性"><a href="#三、项目的属性" class="headerlink" title="三、项目的属性"></a>三、项目的属性</h2><table><thead><tr><th align="center">属性</th><th align="center">用法</th></tr></thead><tbody><tr><td align="center"><code>order</code></td><td align="center">项目的排列顺序</td></tr><tr><td align="center"><code>flex-grow</code></td><td align="center">如何换行</td></tr><tr><td align="center"><code>flex-shrink</code></td><td align="center">是否压缩</td></tr><tr><td align="center"><code>flex-basis</code></td><td align="center">项目占据的主轴空间（<code>main size</code>）</td></tr><tr><td align="center"><code>flex</code></td><td align="center"><code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写</td></tr><tr><td align="center"><code>align-self</code></td><td align="center">单个项目的对齐方式</td></tr></tbody></table><h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">  <span class="comment">/* 填写整数 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p><h3 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（<code>main size</code>）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>,<code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> Flex </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise对象</title>
      <link href="/2019/09/19/Promise%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/09/19/Promise%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>Promise是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理更强大。</p><a id="more"></a><h2 id="Primise的特点："><a href="#Primise的特点：" class="headerlink" title="Primise的特点："></a>Primise的特点：</h2><ol><li><p>对象的状态不受外界音箱。<code>promise</code> 对象代表一个异步操作，有三种状态 <code>pending</code> (进行中)、<code>fulfilled</code> (已成功)和<code>rejected</code> (已失败)。只有异步操作的结果可以决定当前的是哪一种状态。</p></li><li><p>一旦状态改变，就不会再变。<code>Promise</code> 对象的状态改变只有两种可能：从<code>pending</code> 变为<code>fulfilled</code> 和从<code>pending</code> 变成<code>reject</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 <code>resolved</code>（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（<code>Event</code>）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ol><p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><code>Promise</code>对象是一个构造函数，所以我们可以通过new的形式创建<code>Promise</code>实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为<code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从<code>pending</code> 变为<code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p><p><strong>Promise 新建后就会立即执行。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>下面是异步加载图片的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</span><br></pre></td></tr></table></figure><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/1.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON</code>产生，两个由<code>then</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch</code>捕获。</p><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。</p><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p><code>Promise.resolve</code>等价于下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> Promise </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript中call、apply、bind的用法</title>
      <link href="/2019/09/18/Javascript%E4%B8%ADcall%E3%80%81apply%E3%80%81bind%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2019/09/18/Javascript%E4%B8%ADcall%E3%80%81apply%E3%80%81bind%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>call、apply、bind方法都是把函数临时赋值到对象上并执行（改变this指向）。</p><a id="more"></a><p>先看明白下面：<br>例一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"小王"</span>， age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"小张"</span>，</span><br><span class="line">    objAge: <span class="keyword">this</span>.age;</span><br><span class="line">    myFun: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"年龄"</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.objAge; <span class="comment">// 17</span></span><br><span class="line">obj.myFun(); <span class="comment">// 小张年龄 undefined</span></span><br></pre></td></tr></table></figure><p>例二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fav = <span class="string">"盲僧"</span>；</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shows</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.fav);</span><br><span class="line">&#125;</span><br><span class="line">shows(); <span class="comment">// 盲僧</span></span><br></pre></td></tr></table></figure><p>上述两个例子的this，第一个打印里面的this指向obj，第二个全局声明的shows()函数this是windows。</p><h2 id="call-、apply-、bind-都是用来重定义-this-这个对象的！"><a href="#call-、apply-、bind-都是用来重定义-this-这个对象的！" class="headerlink" title="call()、apply()、bind() 都是用来重定义 this 这个对象的！"></a>call()、apply()、bind() 都是用来重定义 this 这个对象的！</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"小王"</span>， age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"小张"</span>，</span><br><span class="line">    objAge: <span class="keyword">this</span>.age，</span><br><span class="line">    myFun: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"年龄"</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name: <span class="string">"德玛"</span>，</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line">obj.myFun.call(db); <span class="comment">//德玛年龄 99</span></span><br><span class="line">obj.myFun.apply(db); <span class="comment">//德玛年龄 99</span></span><br><span class="line">obj.muFun.bind(db)(); <span class="comment">//德玛年龄 99</span></span><br></pre></td></tr></table></figure><p>以上出了 bind 方法后面多了个 () 外 ，结果返回都一致！</p><p><strong>由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。</strong></p><h2 id="对比call、bind、apply传参情况"><a href="#对比call、bind、apply传参情况" class="headerlink" title="对比call、bind、apply传参情况"></a>对比call、bind、apply传参情况</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"小王"</span>， age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"小张"</span>，</span><br><span class="line">    objAge: <span class="keyword">this</span>.age，</span><br><span class="line">    myFun: <span class="function"><span class="keyword">function</span> (<span class="params">from， to</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`</span></span><br><span class="line"><span class="string">            <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>年龄: <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> 来自<span class="subst">$&#123;<span class="keyword">from</span>&#125;</span>去往<span class="subst">$&#123;to&#125;</span></span></span><br><span class="line"><span class="string">        `</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name: <span class="string">"德玛"</span>，</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line">obj.myFun.call(db,<span class="string">'成都'</span>,<span class="string">'上海'</span>)； </span><br><span class="line"><span class="comment">// 德玛 年龄 99  来自 成都去往上海</span></span><br><span class="line">obj.myFun.apply(db,[<span class="string">'成都'</span>,<span class="string">'上海'</span>])； </span><br><span class="line"><span class="comment">// 德玛 年龄 99  来自 成都去往上海  </span></span><br><span class="line">obj.myFun.bind(db,<span class="string">'成都'</span>,<span class="string">'上海'</span>)()； </span><br><span class="line"><span class="comment">// 德玛 年龄 99  来自 成都去往上海</span></span><br><span class="line">obj.myFun.bind(db,[<span class="string">'成都'</span>,<span class="string">'上海'</span>])()；</span><br><span class="line"><span class="comment">// 德玛 年龄 99  来自 成都, 上海去往 undefined</span></span><br></pre></td></tr></table></figure><p>从上面四个结果不难看出:</p><p>call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：</p><p>call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 <code>obj.myFun.call(db,&#39;成都&#39;, ... ,&#39;string&#39; )</code>。</p><p>apply 的所有参数都必须放在一个数组里面传进去 <code>obj.myFun.apply(db,[&#39;成都&#39;, ..., &#39;string&#39; ])</code>。</p><p>bind 除了返回是函数以外，它 的参数和 call 一样。</p><p>当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！</p><pre><code>原文地址：https://www.cnblogs.com/Shd-Study/p/6560808.html</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手动封装ajax请求兼容性写法</title>
      <link href="/2019/09/17/%E6%89%8B%E5%8A%A8%E5%B0%81%E8%A3%85ajax%E8%AF%B7%E6%B1%82%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95/"/>
      <url>/2019/09/17/%E6%89%8B%E5%8A%A8%E5%B0%81%E8%A3%85ajax%E8%AF%B7%E6%B1%82%E5%85%BC%E5%AE%B9%E6%80%A7%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><ul><li>AJAX = 异步 JavaScript 和 XML。</li><li>AJAX 是一种用于创建快速动态网页的技术。</li><li>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<a id="more"></a></li></ul><h2 id="如何封装"><a href="#如何封装" class="headerlink" title="如何封装"></a>如何封装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化HTTP请求参数（请求方式，地址，回调函数，请求数据，同步异步）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">method, url, callback, data, flag</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> xml = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 兼容性写法</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpReauest)&#123;</span><br><span class="line">        <span class="comment">// 创建ajax对象（试用火狐谷歌IE7及以上）</span></span><br><span class="line">        xml = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 兼容IE6及以下</span></span><br><span class="line">        xml = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHttp"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将请求方式转换成大写</span></span><br><span class="line">    method = method.toUpperCase();</span><br><span class="line">    <span class="comment">// 判断请求方式</span></span><br><span class="line">    <span class="keyword">if</span>(method == <span class="string">"GET"</span>)&#123;</span><br><span class="line">        <span class="comment">//定义一个时间戳，避免每次请求地址一样</span></span><br><span class="line">        <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        timer = date.getTime();</span><br><span class="line">        <span class="comment">// 初始化HTTP请求参数(请求方式,地址+参数,同步异步)</span></span><br><span class="line">        xml.open(method, url + <span class="string">"?"</span> + data+ <span class="string">"$timer="</span> + timer, flag);</span><br><span class="line">        xml.send();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(method == <span class="string">"POST"</span>)&#123;</span><br><span class="line">        xml.open(method, url, flag);</span><br><span class="line">        <span class="comment">// post传值需要规定请求头（设置内容类型）</span></span><br><span class="line">        xml.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">        xml.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听数据</span></span><br><span class="line">    xml.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xml.readyState);</span><br><span class="line">        <span class="comment">//readyState的五种状态</span></span><br><span class="line">        <span class="comment">// 0 - （未初始化）还没有调用send()方法</span></span><br><span class="line">        <span class="comment">// 1 - （载入）已调用send()方法，正在发送请求</span></span><br><span class="line">        <span class="comment">// 2 - （载入完成）send()方法执行完成，已经接收到全部响应内容</span></span><br><span class="line">        <span class="comment">// 3 - （交互）正在解析响应内容</span></span><br><span class="line">        <span class="comment">// 4 - （完成）响应内容解析完成，可以在客户端调用了</span></span><br><span class="line">        <span class="keyword">if</span>(xml.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">//检查数据Http状态码：</span></span><br><span class="line">            <span class="comment">//100:信息类，表示web浏览器请求，正在进一步处理中</span></span><br><span class="line">            <span class="comment">//200:成功，表示用户请求被正确接收正在进步一的处理中</span></span><br><span class="line">            <span class="comment">//300:表示请求没有成功，客户端必须采取进一步的操作</span></span><br><span class="line">            <span class="comment">//400:客户端错误，表示客户端提交的请求有错误，如404</span></span><br><span class="line">            <span class="comment">//500:服务器错误，表示服务器不能完成对请求的处理</span></span><br><span class="line">            <span class="comment">//若是为200时，说明数据成功，调用回调函数处理数据，可以通过其他状态码拓展失败的回调函数</span></span><br><span class="line">            <span class="keyword">if</span>(xml.status == <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="comment">// 将请求到的内容作为参数传给回调函数并执行</span></span><br><span class="line">                callback(xml.responseText);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用封装的Ajax"><a href="#使用封装的Ajax" class="headerlink" title="使用封装的Ajax"></a>使用封装的Ajax</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 先引入封装好的Ajax文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./ajax.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> cpage = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">   <span class="comment">//通过GET调用ajax方法</span></span></span><br><span class="line"><span class="javascript">   <span class="comment">//请求方式、路径、回调函数、传值、是否异步</span></span></span><br><span class="line"><span class="javascript">   ajax(<span class="string">'GET'</span>, <span class="string">'getPics.php'</span>, dealData, <span class="string">"cpage="</span> + cpage, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">   <span class="comment">//定义一个回调函数</span></span></span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">callBack</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">       <span class="comment">//将获取到的json格式字符串转换成json格式</span></span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(data);</span></span><br><span class="line"><span class="javascript">       <span class="built_in">console</span>.log(data);</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>需要注意的是，<code>ajax</code>接收到的值是<code>JSON</code>格式的字符串，需要转换成 <code>JSON</code> 格式才可以当对象来使用</li></ul><h2 id="JSON格式转换"><a href="#JSON格式转换" class="headerlink" title="JSON格式转换"></a>JSON格式转换</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>,<span class="string">"age"</span>: <span class="number">18</span>&#125;;</span><br><span class="line"><span class="comment">// 将json格式转换成字符串</span></span><br><span class="line"><span class="keyword">var</span> strData = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line"><span class="comment">// 得到："&#123;"name": "小明","age": 18&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将strData转换成json</span></span><br><span class="line"><span class="keyword">var</span> jsonData = <span class="built_in">JSON</span>.parse(strData);</span><br><span class="line"><span class="comment">// 得到：&#123;name: "小明", age: 18&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
          <category> ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="/2019/09/09/%E9%97%AD%E5%8C%85/"/>
      <url>/2019/09/09/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><p>闭包是由函数以及创建该函数的语法环境组成而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。</p><h4 id="闭包的三要素："><a href="#闭包的三要素：" class="headerlink" title="闭包的三要素："></a>闭包的三要素：</h4><ol><li>嵌套结构的函数</li><li>内部函数访问了外部函数的变量</li><li>在外部函数的外面调用了内部函数<a id="more"></a></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fe = fn();</span><br><span class="line">fe(); <span class="comment">// 2</span></span><br><span class="line">fe(); <span class="comment">// 3</span></span><br><span class="line">fe(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面函数通过return，在外部函数调用内部函数，当然也可以通过其他方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fe;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    fe = <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">fe(); <span class="comment">// 2</span></span><br><span class="line">fe(); <span class="comment">// 3</span></span><br><span class="line">fe(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>上面函数通过全局变量的方法访问到了fe，所以只要外部函数的外面调用了内部函数，就可以实现闭包。</p><h4 id="每次执行都会创建一个独立的闭包对象"><a href="#每次执行都会创建一个独立的闭包对象" class="headerlink" title="每次执行都会创建一个独立的闭包对象"></a>每次执行都会创建一个独立的闭包对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fe1 = fn();</span><br><span class="line"><span class="keyword">var</span> fe2 = fn()</span><br><span class="line">fe1(); <span class="comment">// 2</span></span><br><span class="line">fe1(); <span class="comment">// 3</span></span><br><span class="line">fe1(); <span class="comment">// 4</span></span><br><span class="line">fe2(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码通过执行fn创建了两个闭包</p><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><ol><li>在循环体创建闭包</li><li>使用多个闭包</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showID</span>(<span class="params">id</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'li:'</span> + id)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">setClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ary = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; ary.length; i++)&#123;</span></span><br><span class="line"><span class="javascript">            ary[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line">                showID(i+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    setClick();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码，点击任意一个li都会打印出来5。<br><strong>怎么解决？</strong></p><ol><li><p>可以通过闭包工厂创建独立的闭包对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showID</span>(<span class="params">id</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'li:'</span> + id)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">clickMake</span>(<span class="params">id</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line">            showID(id)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">setClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ary = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; ary.length; i++)&#123;</span></span><br><span class="line">            ary[i].onclick = clickMake(i+1)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    setClick();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>也可以通过立即执行函数解决</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showID</span>(<span class="params">id</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'li:'</span> + id)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">setClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ary = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                ary[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">                showID(i+1);</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;)()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setClick();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>ES6新增了let命令，我们可以直接用let定义一个局部变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showID</span>(<span class="params">id</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'li:'</span> + id)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">setClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ary = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; ary.length; i++)&#123;</span></span><br><span class="line"><span class="javascript">            ary[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line">                showID(i+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    setClick();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> 闭包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的搭建（三）</title>
      <link href="/2019/09/08/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2019/09/08/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>博客如何搭建以及常用的API，前两篇我已经介绍过了，关于主题的个性化配置网络上一搜一大堆文章，我就不细说了，本文主要记录了博主在搭建博客踩的坑以及解决方法。</p><a id="more"></a><h6 id="1-在主题个性化配置的时候，网络上有很多修改CSS样式的文章，文章里经常把要更改的样式写在某一个具体的文件内，有一些文件本地根本找不到（可能是因为hexo版本更新的原因）。"><a href="#1-在主题个性化配置的时候，网络上有很多修改CSS样式的文章，文章里经常把要更改的样式写在某一个具体的文件内，有一些文件本地根本找不到（可能是因为hexo版本更新的原因）。" class="headerlink" title="1. 在主题个性化配置的时候，网络上有很多修改CSS样式的文章，文章里经常把要更改的样式写在某一个具体的文件内，有一些文件本地根本找不到（可能是因为hexo版本更新的原因）。"></a>1. 在主题个性化配置的时候，网络上有很多修改CSS样式的文章，文章里经常把要更改的样式写在某一个具体的文件内，有一些文件本地根本找不到（可能是因为<code>hexo</code>版本更新的原因）。</h6><p><strong>解决办法:</strong><br>可以通过在主题样式的根目录里面添加CSS样式。<br>例如：我使用的是<code>next-Pisces</code>主题样式，可以直接在<code>hemes\next\source\css\_mixins\Pisces.styl</code>文件中直接添加CSS样式。</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加网页背景图片</span></span><br><span class="line"><span class="selector-tag">html</span> <span class="selector-tag">body</span> &#123;</span><br><span class="line">    background:url(https://source.unsplash.com/random/1600x900);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-size</span>:cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-通过hexo-serve进行本地预览，经常有些样式并没有生效，或者通过hexo-deploy上传之后再打开有些样式或者文章无法正常显示。"><a href="#2-通过hexo-serve进行本地预览，经常有些样式并没有生效，或者通过hexo-deploy上传之后再打开有些样式或者文章无法正常显示。" class="headerlink" title="2. 通过hexo serve进行本地预览，经常有些样式并没有生效，或者通过hexo deploy上传之后再打开有些样式或者文章无法正常显示。"></a>2. 通过<code>hexo serve</code>进行本地预览，经常有些样式并没有生效，或者通过<code>hexo deploy</code>上传之后再打开有些样式或者文章无法正常显示。</h6><p><strong>解决办法:</strong><br>可以通过<code>hexo clean</code>，清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><h6 id="3-当通过npm安装了一些插件之后，再进行博客本地预览，hexo报错Plugin-load-failed或者no-such-file-or-directory，提醒我们需要重新通过npm下载插件。"><a href="#3-当通过npm安装了一些插件之后，再进行博客本地预览，hexo报错Plugin-load-failed或者no-such-file-or-directory，提醒我们需要重新通过npm下载插件。" class="headerlink" title="3. 当通过npm安装了一些插件之后，再进行博客本地预览，hexo报错Plugin load failed或者no such file or directory，提醒我们需要重新通过npm下载插件。"></a>3. 当通过npm安装了一些插件之后，再进行博客本地预览，hexo报错<code>Plugin load failed</code>或者<code>no such file or directory</code>，提醒我们需要重新通过npm下载插件。</h6><p><strong>解决办法:</strong><br>因为国内使用npm下载插件是非常慢的，所以我们经常使用cnpm（淘宝镜像）进行下载，需要注意的是当你混用npm和cnpm的时候，本地cnpm下载的插件会被自动删除掉，所以会导致报错插件加载失败，（尽量不要混用）重新下载即可。</p><h6 id="4-博客添加本地搜索插件之后，页面层次混乱，搜索框无法正常显示。"><a href="#4-博客添加本地搜索插件之后，页面层次混乱，搜索框无法正常显示。" class="headerlink" title="4. 博客添加本地搜索插件之后，页面层次混乱，搜索框无法正常显示。"></a>4. 博客添加本地搜索插件之后，页面层次混乱，搜索框无法正常显示。</h6><p><strong>解决办法:</strong><br>博主在搭建本地搜索框的时候，发现搜索框显示在文章主体后，调整<code>z-index</code>也无法正常显示，最后发现是因为我给主体设置了<code>opacity</code>属性。<code>opacity</code>属性默认会改变子元素的透明度，所以会导致页面层次混乱。<br>我们可以改用<code>background-color: rgba(255, 255, 255, 0.8)</code>改变透明度。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的搭建（二）</title>
      <link href="/2019/09/08/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/09/08/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>使用了一段时间的<code>hexo</code>，下面是我整理出来一些常用的<code>hexo</code>指令。</p><a id="more"></a><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p><code>Front-matter</code>是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 博客的搭建（一）</span><br><span class="line">date: 2019-08-23 22:14:57</span><br><span class="line">tags: [" Hexo"]</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">  - </span>[博客搭建, Hexo]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="center"><code>layout</code></td><td align="center">布局</td><td align="left"></td></tr><tr><td align="center"><code>title</code></td><td align="center">标题</td><td align="left"></td></tr><tr><td align="center"><code>date</code></td><td align="center">建立日期</td><td align="left">文件建立日期</td></tr><tr><td align="center"><code>updated</code></td><td align="center">更新日期</td><td align="left">文件更新日期</td></tr><tr><td align="center"><code>comments</code></td><td align="center">开启文章的评论功能</td><td align="left">true</td></tr><tr><td align="center"><code>tags</code></td><td align="center">标签（不适用于分页）</td><td align="left"></td></tr><tr><td align="center"><code>categories</code></td><td align="center">分类（不适用于分页）</td><td align="left"></td></tr><tr><td align="center"><code>permalink</code></td><td align="center">覆盖文章网址</td><td align="left"></td></tr><tr><td align="center"><code>keywords</code></td><td align="center">仅用于 <code>meta</code> 标签和 <code>Open Graph</code> 的关键词</td><td align="left">（不推荐使用）</td></tr></tbody></table><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>在新建文章时，<code>Hexo</code> 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，可以在<code>scaffolds</code> 文件夹中的相应文件修改模板。</p><h2 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h2><p>只有文章支持分类和标签，可以在 <code>Front-matter</code> 中设置。<br>在其他系统中，分类和标签听起来很接近，但是在 <code>Hexo</code> 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="init：新建一个网站"><a href="#init：新建一个网站" class="headerlink" title="init：新建一个网站"></a>init：新建一个网站</h3><pre><code>$ hexo init [folder]</code></pre><p>如果没有设置 <code>folder</code> ，<code>Hexo</code> 默认在目前的文件夹建立网站。</p><h3 id="new：新建一篇文章"><a href="#new：新建一篇文章" class="headerlink" title="new：新建一篇文章"></a>new：新建一篇文章</h3><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。<br>    $ hexo new “post title with whitespace”</p><h3 id="generate：生成静态文件"><a href="#generate：生成静态文件" class="headerlink" title="generate：生成静态文件"></a>generate：生成静态文件</h3><pre><code>$ hexo generate</code></pre><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--deploy</code></td><td>文件生成后立即部署网站</td></tr><tr><td><code>-w</code>, <code>--watch</code></td><td>监视文件变动</td></tr><tr><td><code>-b</code>, <code>--bail</code></td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td><code>-f</code>, <code>--force</code></td><td>强制重新生成文件<code>Hexo</code>引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。使用该参数的效果接近 <code>hexo clean</code> &amp;&amp; <code>hexo generate</code></td></tr></tbody></table><p>该命令可以简写为</p><pre><code>$ hexo g</code></pre><h3 id="server：启动服务器"><a href="#server：启动服务器" class="headerlink" title="server：启动服务器"></a>server：启动服务器</h3><pre><code>$ hexo serve</code></pre><p>默认情况下，访问网址为：<code>http://localhost:4000/</code>。</p><h3 id="deploy：部署网站"><a href="#deploy：部署网站" class="headerlink" title="deploy：部署网站"></a>deploy：部署网站</h3><pre><code>$ hexo deploy</code></pre><p>注意：部署之前需要先生成静态文件<code>hexo generat</code></p><h3 id="clean：清除缓存文件"><a href="#clean：清除缓存文件" class="headerlink" title="clean：清除缓存文件"></a>clean：清除缓存文件</h3><pre><code>$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。<br>注意：在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set数据结构</title>
      <link href="/2019/09/07/Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/09/07/Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set本身是一个构造器，可以通过new来生成Set数据结构</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="comment">// 通过add()向Set结构加入成员</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">for</span> s)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 4</span></span><br></pre></td></tr></table></figure><h3 id="Set函数可以接受一个数组，用来初始化"><a href="#Set函数可以接受一个数组，用来初始化" class="headerlink" title="Set函数可以接受一个数组，用来初始化"></a>Set函数可以接受一个数组，用来初始化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1,2,3,1,2,3]);</span><br><span class="line">[...<span class="keyword">set</span>]</span><br><span class="line">// [1, 2, 3]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">const items = new Set([1,2,3,4,5,5,5,5]);</span><br><span class="line">items.size</span><br><span class="line">// 5</span><br></pre></td></tr></table></figure><p>可以通过Set的特性进行数组去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)]</span><br></pre></td></tr></table></figure><p>也可以用于去除字符串里重复的字符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">'ababbc'</span>)].join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// "abc"</span></span><br></pre></td></tr></table></figure><p>向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。<br>但是Set内部认为NaN是相等的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">let a = NaN;</span><br><span class="line">let b = NaN;</span><br><span class="line"><span class="keyword">set</span>.add(a);</span><br><span class="line"><span class="keyword">set</span>.add(b);</span><br><span class="line"><span class="keyword">set</span> // Set &#123;<span class="literal">NaN</span>&#125;</span><br></pre></td></tr></table></figure><p>另外，两个对象总是不相等的，即使是两个空对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size // 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(&#123;&#125;);</span><br><span class="line"><span class="keyword">set</span>.size // 2</span><br></pre></td></tr></table></figure><h3 id="Set实例的属性方法"><a href="#Set实例的属性方法" class="headerlink" title="Set实例的属性方法"></a>Set实例的属性方法</h3><ol><li>Set.prototype.add(value)：添加某个值，返回 Set 结构本身。</li><li>Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li><li>Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。</li><li>Set.prototype.clear()：清除所有成员，没有返回值。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line"></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">s.delete(<span class="number">2</span>);</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Array-from方法可以将-Set-结构转为数组。"><a href="#Array-from方法可以将-Set-结构转为数组。" class="headerlink" title="Array.from方法可以将 Set 结构转为数组。"></a>Array.from方法可以将 Set 结构转为数组。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><ol><li>Set.prototype.keys()：返回键名的遍历器</li><li>Set.prototype.values()：返回键值的遍历器</li><li>Set.prototype.entries()：返回键值对的遍历器</li><li>Set.prototype.forEach()：使用回调函数遍历每个成员</li></ol><p>需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">for (let item of <span class="keyword">set</span>.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="keyword">set</span>.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ["red", "red"]</span></span><br><span class="line"><span class="comment">// ["green", "green"]</span></span><br><span class="line"><span class="comment">// ["blue", "blue"]</span></span><br></pre></td></tr></table></figure><p>上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype[<span class="built_in">Symbol</span>.iterator] === <span class="built_in">Set</span>.prototype.values</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这意味着，可以省略values方法，直接用for…of循环遍历 Set。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"></span><br><span class="line">for (let x of <span class="keyword">set</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> Set </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> Set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的基础使用</title>
      <link href="/2019/09/07/git%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/07/git%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>本文介绍了git的基础命令，以及工作过程中如何使用git<a id="more"></a></li></ul><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><blockquote><p>git config –global user.name <name><br>git config –global user.email <email></email></name></p></blockquote><h3 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h3><blockquote><p>git config –list</p></blockquote><h3 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h3><ol><li>目录初始化:  git init</li><li>克隆现有仓库:  git clone <url></url></li></ol><h3 id="删除仓库内容"><a href="#删除仓库内容" class="headerlink" title="删除仓库内容"></a>删除仓库内容</h3><ol><li>在本地仓库删除指定文件： git rm 文件名称</li><li>在本地仓库删除指定文件： git rm -r 文件夹名称</li><li>提交修改： git commit -m “”</li><li>推送到远程仓库： git push</li></ol><p>三个工作区域：工作目录，暂存区域，Git仓库</p><p>已快照的形式存储</p><p>Git更新状态命令</p><p>追踪文件与暂存已经修改文件  git add .<br>提交更新  git commit -m “第一次提交”<br>查看状态  git status<br>比较工作目录和暂存区域   git diff<br>比较暂存区域和上版本的区别 git diff –staged<br>比较工作目录和上版本的区别 git diff HEAD</p><p>查看提交历史 git log</p><p>Git撤销<br>撤销到暂存  git reser HEAD –<file><br>撤销暂存   git checkout –<file></file></file></p><p>Git分支：指针<br>默认分支 master<br>创建分支 git branch <name></name></p><p>HEAD 指针<br>切换分支 git checkout &lt;名字&gt;</p><h3 id="工作中使用分支：不要在主分支上修改代码"><a href="#工作中使用分支：不要在主分支上修改代码" class="headerlink" title="工作中使用分支：不要在主分支上修改代码"></a>工作中使用分支：不要在主分支上修改代码</h3><p>合并分支（切换到主分支） git merge &lt;分支&gt;</p><p>以本地仓库为基准</p><ol><li>创建一个新的仓库</li><li>与git仓库创建连接：git remote add origin <url></url></li><li>提交本地origin分支到远程master分支上：git push origin master</li><li>提交简写(下次提交直接git push 就可以)： git push -u origin master</li><li>查看所有版本：git branch -v</li></ol><p>以远程仓库为基准</p><blockquote><p>git clone url</p></blockquote><p>多人协作<br>拉取：git fetch <name><br>合并：git merge <branch><br>拉取加合并：git pull <name> <branch><br>推送：git push <name> <branch></branch></name></branch></name></branch></name></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> git基础使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios的基础使用</title>
      <link href="/2019/09/02/axios%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/02/axios%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>本文介绍了axios的基础使用<a id="more"></a></li></ul><h3 id="npm下载"><a href="#npm下载" class="headerlink" title="npm下载"></a>npm下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure><h3 id="引入axios"><a href="#引入axios" class="headerlink" title="引入axios"></a>引入axios</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span></span><br></pre></td></tr></table></figure><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><h3 id="通过axios-post-发送一个数据"><a href="#通过axios-post-发送一个数据" class="headerlink" title="通过axios.post()发送一个数据"></a>通过axios.post()发送一个数据</h3><ul><li>第一个参数填请求的地址</li><li>第二个参数填请求头（对象的形式，也可以不写）</li><li>第三个参数填要传的数据</li><li>发送完请求会返回一个promise对象，可以通过.then()执行回调函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">"https://myapp-92091.firebaseio.com/user.json"</span>)</span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line">.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="get请求使用方式一样"><a href="#get请求使用方式一样" class="headerlink" title="get请求使用方式一样"></a>get请求使用方式一样</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">"https://myapp-92091.firebaseio.com/user.json"</span>)</span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line">.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 数据处理</span></span><br><span class="line">&#125;,(err)=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Config-Defaults"><a href="#Config-Defaults" class="headerlink" title="Config Defaults"></a>Config Defaults</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.buseURL = <span class="string">"https://myapp-92091.firebaseio.com"</span></span><br><span class="line"><span class="comment">// 配置请求头（get，post，common）</span></span><br><span class="line">axios.defaults.header.common[<span class="string">"Authorization"</span>] = <span class="string">"AUTH_TOKEN"</span></span><br></pre></td></tr></table></figure><h3 id="Interceptors"><a href="#Interceptors" class="headerlink" title="Interceptors"></a>Interceptors</h3><ul><li>可以在处理请求或响应之前拦截它们。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个发送数据前的拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在发送请求处理数据，也可以加loading</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理请求错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个请求数据回来的拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 数据处理</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理响应错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>也可以创建一个新的axios实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create()</span><br><span class="line">instance.defaults.baseURL = <span class="string">""</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> vue基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex状态管理</title>
      <link href="/2019/08/30/Vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/30/Vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>本文介绍了Vuex的基础使用<a id="more"></a><h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3></li></ul><ol><li>可以通过npm下载</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><ol start="2"><li>通过vue-cli直接创建</li></ol><hr><h3 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h3><ul><li>创建Vuex实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>在任意组件通过计算属性computed获取数据，当数据改变时会立即更新</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    count()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、特性"><a href="#三、特性" class="headerlink" title="三、特性"></a>三、特性</h3><h4 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h4><ul><li>当数据需要处理的时候，使用getters</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">    <span class="comment">// 需要传入state，获取数据</span></span><br><span class="line">        doubleCount(state)&#123;</span><br><span class="line">            <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用方式跟state的方式一样</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">       count()&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.$stroe.getters.doubleCount</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><ul><li>更改Vuex的store中的状态的唯一方法是提交mutation。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increaseCount(state， num)&#123;</span><br><span class="line">            state.count += num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用的时候需要使用$store.commit()方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">        count()&#123;</span><br><span class="line">        <span class="comment">// 执行increment方法</span></span><br><span class="line">            <span class="keyword">this</span>.$store.commit(<span class="string">"increaseCount"</span>， <span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过监听mutations（函数执行）的方式，可以追踪到当前数据的变化。</li><li>注意：mutations只能监听到同步的代码。</li></ul><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><ul><li>Action 类似于 mutation，不同在于：Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increaseCount(state， num)&#123;</span><br><span class="line">        state.count += num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">  <span class="comment">//Action函数接受一个与store实例具有相同方法和属性的context对象</span></span><br><span class="line">    actionsIncrease(context) &#123;</span><br><span class="line">    <span class="comment">// 1s后执行count+5（注意这里需要使用箭头函数）</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 通过context.commit提交一个mutation</span></span><br><span class="line">            context.commit(<span class="string">'increaseCount'</span>, <span class="number">5</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>使用$store.dispatch()分发actions</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        count()&#123;</span><br><span class="line">        <span class="comment">// 触发actionsIncrease（也可以传值）</span></span><br><span class="line">            <span class="keyword">this</span>.$store.dispatch(<span class="string">"actionsIncrease"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vue-devtools"><a href="#Vue-devtools" class="headerlink" title="Vue-devtools"></a>Vue-devtools</h4><ul><li>使用devtools进行数据监听</li></ul><hr><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><ol><li>把数据写在state里面，通过计算属性computed监听数据（实时更新）</li><li>获取数据：this.$store.state</li><li>状态改变：必须提交一个mutations，不可以直接操作数据，这样才可以进行数据监听（devtools），并且通过commit的方法只能是同步的代码。</li><li>异步的代码必须写在actions里，通过actions提交一个mutations修改数据的状态。</li></ol><hr><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h4><h5 id="mapState"><a href="#mapState" class="headerlink" title="mapState"></a>mapState</h5><ul><li>为组件创建计算属性以返回 Vuex store 中的状态。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line">compouted: &#123;</span><br><span class="line"><span class="comment">// 通过mapState获取到count和value的值(函数的形式)</span></span><br><span class="line"><span class="comment">// 相当于count()&#123;return this.$state.count&#125;</span></span><br><span class="line">    ...mapState([<span class="string">"count"</span>, <span class="string">"value"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h5><ul><li>为组件创建计算属性以返回 getter 的返回值。</li><li>使用方法和mapState一样</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState, mapGetters&#125; <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line">compouted: &#123;</span><br><span class="line">    ...mapState([<span class="string">"count"</span>]),</span><br><span class="line">    <span class="comment">// 相当于daubleCount()&#123;return this.$getters.daubleCount&#125;</span></span><br><span class="line">    ...mapGetters([<span class="string">"daubleCount"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="mapActions"><a href="#mapActions" class="headerlink" title="mapActions"></a>mapActions</h5><ul><li>创建组件方法分发 action。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapActions&#125; <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line">compouted: &#123;</span><br><span class="line"><span class="comment">// 相当于actionsIncrease()&#123;this.$store.dispatch("actionsIncrease")&#125;</span></span><br><span class="line">    ...mapActions([<span class="string">"actionsIncrease"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果需要传参可以在事件绑定里直接传</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"actionsIncrease(5)"</span>&gt;</span>每次点击加5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="mapMutations"><a href="#mapMutations" class="headerlink" title="mapMutations"></a>mapMutations</h5><ul><li>使用方法和mapActions一样</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapActions, mapMutations&#125; <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line">compouted: &#123;</span><br><span class="line">    ...mapActions([<span class="string">"actionsIncrease"</span>])，</span><br><span class="line">    ...mapMutations([<span class="string">""</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><ul><li>我们通过计算属性computed监听数据的时候不能直接使用v-model进行数据改变。</li><li>所以我们要通过v-bind和@input自己绑定一个事件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        value: <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        valueGetters(state)&#123;</span><br><span class="line">            <span class="keyword">return</span> state.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        changeValue(state, num)&#123;</span><br><span class="line">            state.value = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="comment">// &#123;commit&#125;是结构赋值的写法</span></span><br><span class="line">        actionsValue(&#123;commit&#125;, num)&#123;</span><br><span class="line">            commit(<span class="string">"changeValue"</span>, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 通过$event.target.value获取当前输入的内容</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">:value</span>=<span class="string">"valueGetters"</span> @<span class="attr">input</span>=<span class="string">"actionsValue($event.target.value)"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapGetters, mapActions&#125; <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line">computed: &#123;</span><br><span class="line"><span class="comment">// 通过计算属性监听valueGetters</span></span><br><span class="line">    ...mapGetters([<span class="string">"valueGetters"</span>])</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="comment">// 分发actions</span></span><br><span class="line">    ...mapActions([<span class="string">"actionsValue"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二种方法</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"valueGetters"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapGetters, mapActions&#125; <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    valueGetters: &#123;</span><br><span class="line">    <span class="comment">// get：获取计算属性应该做什么</span></span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.valueGetters</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 设置valueGetters</span></span><br><span class="line">        <span class="keyword">set</span>(num)&#123;</span><br><span class="line">            <span class="keyword">this</span>.$store.dispatch(<span class="string">"actionsValue"</span>, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="comment">// 分发actions</span></span><br><span class="line">    ...mapActions([<span class="string">"actionsValue"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> vue基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由插件VueRouter</title>
      <link href="/2019/08/29/%E8%B7%AF%E7%94%B1%E6%8F%92%E4%BB%B6VueRouter/"/>
      <url>/2019/08/29/%E8%B7%AF%E7%94%B1%E6%8F%92%E4%BB%B6VueRouter/</url>
      
        <content type="html"><![CDATA[<ul><li>本文介绍了VueRouter的基础使用。</li></ul><a id="more"></a><h2 id="一、基础使用"><a href="#一、基础使用" class="headerlink" title="一、基础使用"></a>一、基础使用</h2><h3 id="如何下载"><a href="#如何下载" class="headerlink" title="如何下载"></a>如何下载</h3><ol><li>可以通过npm下载</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure><ol start="2"><li>也可以通过vue-cli创建项目的时候直接下载<h3 id="如何使用vueRouter"><a href="#如何使用vueRouter" class="headerlink" title="如何使用vueRouter"></a>如何使用vueRouter</h3></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./App.vue"</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"./components/Home"</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">"./components/User"</span></span><br><span class="line"><span class="comment">// 引入vueRouter</span></span><br><span class="line"><span class="keyword">import</span> vueRouter <span class="keyword">from</span> <span class="string">"vue-router"</span></span><br><span class="line"><span class="comment">// 告诉vue需要使用vueRouter</span></span><br><span class="line">vue.use(vueRouter)</span><br><span class="line"><span class="comment">// 通过new创建一个vueRouter实例</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> vueRouter(&#123;</span><br><span class="line">    <span class="comment">// 配置路由</span></span><br><span class="line">    routes： [</span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">component</span>: Home&#125;,</span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">"/user"</span>, <span class="attr">component</span>: User&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    <span class="comment">// 告诉vue我们需要使用哪一个router实例（ES6简写方式）</span></span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>通过router-view在temponent模板里替换组件</li><li>一般我们会创建一个router.js文件，把router的配置都写在里面，然后通过export default{ }暴露出来</li></ul><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><ol><li>hash模式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode: hash</span><br></pre></td></tr></table></figure><ol start="2"><li>history模式</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode: history</span><br></pre></td></tr></table></figure><h3 id="组件切换"><a href="#组件切换" class="headerlink" title="组件切换"></a>组件切换</h3><ol><li>可以通过a标签进行路由跳转</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>跳转到Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/User"</span>&gt;</span>跳转到User<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这样页面会有跳转行为（刷新页面）</li></ul><ol start="2"><li>vueRouter给我们提供了新的组件（不会进行页面跳转），通过to来进行跳转路由</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/User"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>router-link默认渲染成a标签（可以通过tag渲染成li）</li><li>如果想设置选中状态可以通过.router-linkactive设置css样式（”/“是一个模糊的匹配，可以添加关键字exact进行精确匹配）</li><li>如果想更改选中状态的class类名，可以通过active-class=””设置</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">tag</span>=<span class="string">"li"</span> <span class="attr">to</span>=<span class="string">"/"</span> <span class="attr">active-class</span>=<span class="string">"active"</span> <span class="attr">exact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">tag</span>=<span class="string">"li"</span> <span class="attr">to</span>=<span class="string">"/User"</span> <span class="attr">active-class</span>=<span class="string">"active"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>User<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.router-link-active</span>&#123;</span><br><span class="line">    // 样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>还可以通过js来进行切换</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"goToHome"</span>&gt;</span>跳转到主页<span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    goToHome()&#123;</span><br><span class="line">    <span class="comment">// 通过$router获取当前路由的实例，push方法进行跳转路由</span></span><br><span class="line">        <span class="keyword">this</span>.$router.push(<span class="string">"/"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二、使用router-link与动态路由"><a href="#二、使用router-link与动态路由" class="headerlink" title="二、使用router-link与动态路由"></a>二、使用router-link与动态路由</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> vueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">compont</span>: Home&#125;,</span><br><span class="line">        <span class="comment">// 通过：id传值</span></span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">"/user/:id"</span>, <span class="attr">compont</span>: User&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>可以通过$route.params获取到自定义的参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        id: <span class="keyword">this</span>.$route.params.id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 如果想要动态渲染$router.params的值，需要使用watch监听</span></span><br><span class="line">watch: &#123;</span><br><span class="line">    $route(to, <span class="keyword">from</span>)&#123;</span><br><span class="line">    <span class="comment">// to:切换之后的$route, from：切换之前的$route</span></span><br><span class="line">        <span class="keyword">this</span>.id = to.params</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul><li>使用children字段配置，然后在user组件中通过router-view渲染子路由</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> vueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;<span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">compont</span>: Home&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        path: <span class="string">"/user"</span>,</span><br><span class="line">        compont: User,</span><br><span class="line">        children: [&#123;</span><br><span class="line">        <span class="comment">// ""：代表默认显示</span></span><br><span class="line">                path: <span class="string">""</span>,</span><br><span class="line">                component: UserC1</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">                path: <span class="string">":id"</span>,</span><br><span class="line">                component: UserC2</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">                path: <span class="string">":id/edit"</span>,</span><br><span class="line">                component: UserEdit,</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                name: <span class="string">"userEdit"</span></span><br><span class="line">        &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>如果路由嵌套很多层，router-link渲染的时候写起来就很麻烦，我们可以通过name关键字设置路径</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">"/user"</span>,</span><br><span class="line">        component: User,</span><br><span class="line">        children: [&#123;</span><br><span class="line">            path: <span class="string">":id"</span>,</span><br><span class="line">            component: UserC2</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            path: <span class="string">":id/edit"</span>,</span><br><span class="line">            component: userEdit,</span><br><span class="line">            name: <span class="string">"userEdit"</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>通过：to传一个对象，设置当前路由</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>User<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;name: 'userEdit', params: &#123;id: $route.params.id&#125;&#125;"</span>&gt;</span>跳转到userEdit<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; $route.params.id &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="命名组件"><a href="#命名组件" class="headerlink" title="命名组件"></a>命名组件</h3><ul><li>通过name设置组件是否可见</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">"header-top"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line"><span class="comment">// "/"匹配到两个组件，第一个是Home（加载到没有命名的router-view里）,第二个是Header（加载到header-top）</span></span><br><span class="line">       &#123;<span class="attr">path</span>: <span class="string">"/"</span>, <span class="attr">components</span>: &#123;</span><br><span class="line">       <span class="comment">// 默认显示的组件</span></span><br><span class="line">           <span class="keyword">default</span>: Home，</span><br><span class="line">           <span class="string">"header-top"</span>: Header</span><br><span class="line">       &#125;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul><li>当输入一个错误的path时，需要进行重定向</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// "*":所有未定义的路由</span></span><br><span class="line">path: <span class="string">"*"</span></span><br><span class="line"><span class="comment">// 重定向</span></span><br><span class="line">    redirect： err</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、过渡动画"><a href="#三、过渡动画" class="headerlink" title="三、过渡动画"></a>三、过渡动画</h2><ul><li>router-view始终只显示一个组件，因此符合transition的要求（只能加载一个组件），所以可以通过transition包裹router-view达到路由切换时的动画效果</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用钩子函数设置动画</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> vue基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中From表单的使用</title>
      <link href="/2019/08/28/Vue%E4%B8%ADFrom%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/28/Vue%E4%B8%ADFrom%E8%A1%A8%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>本文详细介绍了From表单在Vue中如何使用。<a id="more"></a></li></ul><h3 id="事件绑定原理"><a href="#事件绑定原理" class="headerlink" title="事件绑定原理"></a>事件绑定原理</h3><ul><li>通过v-model进行数据绑定，v-model主要做了两件事情：<ol><li>初始化当前input框里的value</li><li>监听input事件</li></ol></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"email"</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"email"</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-model</span>=<span class="string">"userInfo.email"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        userInfo: &#123;</span><br><span class="line">            email: <span class="string">"123@qq.com"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>v-model的默认行为：当输入的时候会立即更新数据（实时更新）， 这样很浪费性能，一般情况下我们只需要在input失去焦点的情况下更新数据。</li><li>可以通过修饰符来实现：<ol><li>失去焦点再进行数据更新：v-model.lazy</li><li>去除前面和后面空格：v-model.trim</li><li>把当前字符串转换成数字：v-midel.number</li></ol></li></ul><hr><h3 id="文本域textarea"><a href="#文本域textarea" class="headerlink" title="文本域textarea"></a>文本域textarea</h3><ul><li>文本域textarea是闭合的标签，但是数据绑定仍然要写在标签上，不可以通过双大括号的形式写在标签里</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"message"</span>&gt;</span>信息<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"message"</span></span></span><br><span class="line"><span class="tag"><span class="attr">v-model</span>=<span class="string">"userInfo.message"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        userInfo: &#123;</span><br><span class="line">            message: <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据展示：文本域中可以输入回车以及空格，但是把数据渲染成html展现出来的时候会只显示一个空格，所以需要设置css中white-apace的属性，从而改变显示的形式。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-apace:pre"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="复选框checkbox"><a href="#复选框checkbox" class="headerlink" title="复选框checkbox"></a>复选框checkbox</h3><ul><li>通过v-model绑定相同的值，表示一组复选框，当勾选的时候，会向数组里push数据，当取消勾选会delete对应的数据</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sendmail"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"sendEmail"</span> <span class="attr">value</span>=<span class="string">"SendEMail"</span> <span class="attr">v-model</span>=<span class="string">"sendMail"</span>&gt;</span></span><br><span class="line">订阅邮箱</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sendInfomail"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"sendInfomail"</span> <span class="attr">value</span>=<span class="string">"SendInfoMail"</span> <span class="attr">v-model</span>=<span class="string">"sendMail"</span>&gt;</span></span><br><span class="line">订阅短信</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sendMail: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据展示：可以通过v-for，进行数组循环</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in sendMail"</span> <span class="attr">:key</span>=<span class="string">"tiem"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单选框radio"><a href="#单选框radio" class="headerlink" title="单选框radio"></a>单选框radio</h3><ul><li>与复选框相似，通过v-model绑定相同的数据，代表一组单选框</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"male"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"male"</span> <span class="attr">value</span>=<span class="string">"Male"</span> <span class="attr">v-model</span>=<span class="string">"sex"</span>&gt;</span></span><br><span class="line">男</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"female"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"female"</span> <span class="attr">value</span>=<span class="string">"Female"</span> <span class="attr">v-model</span>=<span class="string">"sex"</span>&gt;</span></span><br><span class="line">女</span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        sex: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉菜单option"><a href="#下拉菜单option" class="headerlink" title="下拉菜单option"></a>下拉菜单option</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"priority"</span>&gt;</span>下拉菜单<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"priority"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"item in priorities"</span> <span class="attr">:key</span>=<span class="string">"item"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        priorities: [<span class="string">"高"</span>， <span class="string">"中"</span>, <span class="string">"低"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置下拉菜单默认选中</li></ul><ol><li>可以通过设置selected来实现</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"priority"</span>&gt;</span>下拉菜单<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"priority"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"item in priorities"</span> <span class="attr">:key</span>=<span class="string">"item"</span> ：<span class="attr">selected</span>=<span class="string">"item == "</span>中""&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>可以通过v-model绑定默认数据到select上</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"priority"</span>&gt;</span>下拉菜单<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"priority"</span> <span class="attr">v-model</span>=<span class="string">"selectItem"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"item in priorities"</span> <span class="attr">:key</span>=<span class="string">"item"</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    selectItem: <span class="string">"低"</span></span><br><span class="line">        priorities: [<span class="string">"高"</span>， <span class="string">"中"</span>, <span class="string">"低"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="在自定义组件中使用"><a href="#在自定义组件中使用" class="headerlink" title="在自定义组件中使用"></a>在自定义组件中使用</h3><ul><li>通过组件之间的传值，$emit()、props实现自定义组件</li><li>使用v-model进行数据绑定，主要做了两件事情：<ol><li>初始化当前input框里的value：可以通过v-bind:value实现</li><li>监听input事件：绑定input事件，获取到输入的值$event.target.value</li></ol></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-bind:value</span>=<span class="string">"name"</span> @<span class="attr">input</span>=<span class="string">"name = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">"name"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><ul><li>注意：当我们提交的时候需要阻止按钮默认事件，然后处理数据（发送请求等）。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"submit"</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    submit()&#123;</span><br><span class="line">        <span class="comment">//数据处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
          <category> vue基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> From </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的搭建（一）</title>
      <link href="/2019/08/23/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/08/23/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>折腾了一晚上，终于把博客搭起来了，用的是Hexo框架，基于Node.js，还需要Git仓库管理代码，在这里推荐大家使用GitHub，所以我们需要安装Git、Node.js以及安装Hexo，并且安装到全局。</p><hr><h3 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h3><p>作为IT工作者，相信大家电脑里应该都安装了Git、Node.js，不会安装的小伙伴可以上网搜一下教程。<br>下面我具体说一下Hexo安装以及使用。</p><a id="more"></a><hr><h4 id="使用npm安装Hexo"><a href="#使用npm安装Hexo" class="headerlink" title="使用npm安装Hexo"></a>使用npm安装Hexo</h4><blockquote><p>$ npm install hexo-cli -g</p></blockquote><p>安装完成后通过hexo-v,查看时候安装成功</p><blockquote><p>$ hexo -v</p></blockquote><h4 id="创建资源文件夹"><a href="#创建资源文件夹" class="headerlink" title="创建资源文件夹"></a>创建资源文件夹</h4><p>安装 Hexo 完成后，在你任一目录下新建文件夹命名为Blog（替换成你喜欢的名字），然后cd到Blog文件夹下</p><blockquote><p>$ cd Blog<br>$ hexo init Blog</p></blockquote><p>根目录创建成功后，需要下载依赖的文件</p><blockquote><p>$ npm install</p></blockquote><p>下载完成后即可开始个性化配置。</p><hr><h3 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h3><h4 id="本地预览博客"><a href="#本地预览博客" class="headerlink" title="本地预览博客"></a>本地预览博客</h4><p>通过hexo serve命令，预览当前博客</p><blockquote><p>$ hexo serve</p></blockquote><p>打开浏览器输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，即可预览当前博客</p><h4 id="创建一篇新的博客"><a href="#创建一篇新的博客" class="headerlink" title="创建一篇新的博客"></a>创建一篇新的博客</h4><p>输入hexo new post + name，可以创建一篇新的博客</p><blockquote><p>hexo new post name</p></blockquote><p>在source/_posts文件夹下会生成一个md文件</p><h4 id="创建主页"><a href="#创建主页" class="headerlink" title="创建主页"></a>创建主页</h4><p>同理通过hexo new page + name，可以创建主页</p><hr><h3 id="三、博客发布"><a href="#三、博客发布" class="headerlink" title="三、博客发布"></a>三、博客发布</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>Hexo给我提供了插件，可以方便我们进行git上传</p><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><p>安装完成之后，需要更改跟目录下的_config.yml文件的内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/username/username.github.io.git</span></span><br></pre></td></tr></table></figure><h4 id="生成Html文件"><a href="#生成Html文件" class="headerlink" title="生成Html文件"></a>生成Html文件</h4><p>上传到Github之前，需要把博客系统编译成html</p><blockquote><p>hexo generat</p></blockquote><h4 id="提交到Git仓库"><a href="#提交到Git仓库" class="headerlink" title="提交到Git仓库"></a>提交到Git仓库</h4><blockquote><p>hexo deploy</p></blockquote><h4 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h4><p>在每次使用hexo generat部署之后，可以先使用 hexo serve 运行本地站点，然后在浏览器输入地址 <a href="http://lacolhost:4000/" target="_blank" rel="noopener">http://lacolhost:4000/</a> 查看运行结果，检查无误后再使用 hexo deploy 发布</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag>  Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
